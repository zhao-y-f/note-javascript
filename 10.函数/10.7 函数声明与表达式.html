<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 本章到现在一直没有把函数声明和函数表达式区分得很清楚。事实上，JavaScript 引擎在加载数据
        // 时对它们是区别对待的。JavaScript 引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中
        // 生成函数定义。而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。来看
        // 下面的例子：
        // 没问题
        console.log(sum(10, 10));
        function sum(num1, num2) {
            return num1 + num2;
        }
        // 以上代码可以正常运行，因为函数声明会在任何代码执行之前先被读取并添加到执行上下文。这个
        // 过程叫作函数声明提升（function declaration hoisting）。在执行代码时，JavaScript引擎会先执行一遍扫描，
        // 把发现的函数声明提升到源代码树的顶部。因此即使函数定义出现在调用它们的代码之后，引擎也会把
        // 函数声明提升到顶部。如果把前面代码中的函数声明改为等价的函数表达式，那么执行的时候就会出错：
        // 会出错
        console.log(sum(10, 10));
        let sum = function (num1, num2) {
            return num1 + num2;
        };
        // 上面的代码之所以会出错，是因为这个函数定义包含在一个变量初始化语句中，而不是函数声明中。
        // 这意味着代码如果没有执行到加粗的那一行，那么执行上下文中就没有函数的定义，所以上面的代码会
        // 出错。这并不是因为使用 let 而导致的，使用 var 关键字也会碰到同样的问题：
            console.log(sum(10, 10));
        var sum = function (num1, num2) {
            return num1 + num2;
        };
        // 除了函数什么时候真正有定义这个区别之外，这两种语法是等价的。
        // 注意 在使用函数表达式初始化变量时，也可以给函数一个名称，比如 let sum =
        //     function sum() { } 。这一点在 10.11 节讨论函数表达式时会再讨论。
    </script>
</body>

</html>